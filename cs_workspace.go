package goapp_generator

import (
	"bytes"
	"fmt"
	"os"
	"time"

	"github.com/dave/jennifer/jen"
	gonanoid "github.com/matoous/go-nanoid/v2"
	"golang.org/x/exp/slog"
)

type FileHandler func(s string) string

type FileData struct {
	jfile        *jen.File
	initCode     []*jen.Statement
	fileHandlers []FileHandler
}

func (f *FileData) clear() {
	f.jfile = nil
	clear(f.fileHandlers)
	clear(f.initCode)
}

type Workspace struct {
	Config *Config

	HasUnknow bool

	class   *Class
	GoFile  *FileData
	goFiles map[string]*FileData
}

func NewWorkspace(c *Config) *Workspace {
	return &Workspace{
		Config:  c,
		goFiles: make(map[string]*FileData),
	}
}

func (ws *Workspace) GUID() string {
	return gonanoid.Must()
}

func (ws *Workspace) AddHandler(f FileHandler) {
	if ws.GoFile != nil {
		ws.GoFile.fileHandlers = append(ws.GoFile.fileHandlers, f)
	}
}

func (ws *Workspace) AddInitCode(s *jen.Statement) {
	if ws.GoFile != nil {
		ws.GoFile.initCode = append(ws.GoFile.initCode, s)
	}
}

func (ws *Workspace) BeginGoFile(cls *Class) *jen.File {
	fn, share := cls.GetGoGenFilePath(ws.Config.RootDirGO)

	var f *FileData
	if share {
		if sf, ok := ws.goFiles[fn]; ok {
			f = sf
		} else {
			jf := jen.NewFilePathName(cls.goGenPkgpath, cls.goGenPkgname)
			f = &FileData{
				jfile: jf,
			}
			ws.goFiles[fn] = f
		}
	} else {
		jf := jen.NewFilePathName(cls.goGenPkgpath, cls.goGenPkgname)
		f = &FileData{
			jfile: jf,
		}
	}
	ws.GoFile = f
	ws.class = cls

	f.jfile.ImportName(GPYTHON_PACK, "")

	return f.jfile
}

func (ws *Workspace) EndGoFile() {
	defer func() {
		ws.GoFile = nil
		ws.class = nil
		ws.HasUnknow = false
	}()

	if ws.GoFile == nil {
		return
	}

	for _, f := range ws.goFiles {
		if f == ws.GoFile {
			// shared, not save
			return
		}
	}

	var fn string
	if ws.class != nil {
		fn, _ = ws.class.GetGoGenFilePath(ws.Config.RootDirGO)
	}

	if fn != "" {
		ws.saveGoFile(fn, ws.GoFile)
	}
}

func (ws *Workspace) saveGoFile(fn string, fd *FileData) {
	defer fd.clear()

	f := fd.jfile
	if len(fd.initCode) > 0 {
		f.Func().Id("init").Params().BlockFunc(func(g *jen.Group) {
			for _, c := range fd.initCode {
				g.Add(c)
			}
		})
	}

	slog.Info("Render", "file", fn)
	buf := bytes.NewBuffer(nil)
	var err error
	if err = f.Render(buf); err != nil {
		slog.Error("RenderFail", "error", err)
		time.Sleep(time.Millisecond)
		s := buf.String()
		fmt.Println(s)
		return
	}

	if ws.HasUnknow {
		slog.Warn("HasUnknow", "file", fn)
		return
	}
	co := buf.String()
	for _, fh := range fd.fileHandlers {
		co = fh(co)
	}
	// co = "// Code generated by goapp_generator. DO NOT EDIT.\n\n" + co

	if ws.Config.GenFile {
		slog.Info("Save", "file", fn)
		err = os.WriteFile(fn, []byte(co), 0644)
		if err != nil {
			slog.Error("SaveFail", "error", err)
		}
	} else {
		time.Sleep(time.Millisecond)
		fmt.Println("######################")
		fmt.Printf("%s\n", co)
		fmt.Println("######################")
	}
}

func (ws *Workspace) EndAll() {
	for fn, f := range ws.goFiles {
		ws.saveGoFile(fn, f)
	}
	clear(ws.goFiles)
}
